# leetcode
    
## ✔ [49. Group Anagrams](https://leetcode.com/problems/group-anagrams/)

### 내용

애너그램은 특정 문자열의 문자를 재배치하여 만든 새로운 문자열이다. 여러 개의 문자열이 배열로 주어질 때 애너그램으로 짝지어보자.

### 풀이

문제를 보자마자 엑셀에서의 '중복 제거'가 떠올랐다. 즉, 특정 대상의 통계를 구하기 위해서는 해당 대상을 중복 제거하여야 한다. 이를 가능케 하는 방법으로 다음과 같이 크게 2가지를 떠올려보았다.

1. 문자열을 구성하는 문자의 ascii 코드의 총 합을 기준으로 중복 제거가 가능하다.
2. 문자열을 구성하는 문자를 정렬하면 중복을 제거할 수 있다.

이 중에서 첫 번째 방법보다는 두 번째 방법이 훨씬 직관적인 코드를 작성할 수 있을 것으로 예상되어 두 번째 방법으로 시도해보았다.

1. 딕셔너리의 key는 문자열의 문자를 정렬하여 만든 새로운 문자열로 하고, value는 빈 리스트로 한다.
 
```python
groups = {''.join(sorted(word)): [] for word in strs}
```

2. 입력받은 문자열 리스트를 반복하는 동안 key 값을 현재 문자를 정렬한 새로운 문자열로 하여 `1`의 딕셔너리에 접근하고, key에 해당하는 리스트에 현재 문자열을 추가한다.
   
```python
for word in strs:
    groups[''.join(sorted(word))].append(word)
```

3. `1`의 딕셔너리에서 value만 리스트로 반환한다.

```python
return list(groups.values())
```

## ✔ [409. Longest Palindrome](https://leetcode.com/problems/longest-palindrome/)

### 내용

팰린드롬은 문자열의 가운데를 기준으로 하여 2개로 나누었을 때, 첫 번째 문자열과 두 번째 문자열의 역순이 같은 문자열을 말한다.

### 풀이

팰린드롬의 규칙성을 다음과 같이 정리해보았다.

1. 문자열을 구성하는 문자의 개수가 모두 짝수인 경우 모든 문자를 팰린드롬으로 배치 가능 `ex) 'aabbcc' -> 'aabbcc'`
2. 문자열을 구성하는 문자의 개수 중 홀수가 포함되어 있는 경우 개수가 홀수인 문자를 짝수로 활용하고, 가운데에 홀수인 문자로 하여 팰린드롬으로 배치 가능 `ex) 'aaabbbccc' -> 'abcccba'`

따라서. 문자열을 구성하는 문자의 개수가 홀수인 경우 이를 짝수로 만들고, 문자열의 가운데에 끼워줄 홀수 개의 문자 1개를 나중에 더하는 방식으로 접근하였다.

1. 문자열을 구성하는 문자의 개수를 파악하여 딕셔너리에 저장한다.

```python
counters = {c: s.count(c) for c in s}
```

2. 문자 중에 홀수가 있는지 파악하기 위한 변수를 정의하고, 아직까지는 없다는 의미인 0으로 초기화한다.

```python
is_exist_odd = 0
```

3. 반복문을 통해 `1`의 딕셔너리의 key, value를 순차적으로 불러오고, 현재 value가 홀수인 경우 해당 value를 짝수로 만든다. 그리고, 홀수개인 문자가 존재하므로 `2`의 값을 1로 변경한다.

```python
for character, count in counters.items():
    if count % 2 == 1:
        counters[character] = count - 1
        is_exist_odd = 1
```

4. `3`의 과정으로 인해 전부 짝수가 된 `1`의 딕셔너리의 value를 모두 합산한 후, 홀수개인 문자를 가운데에 추가하기 위해 `2`의 값을 더한다.

```python
return sum(list(counters.values())) + is_exist_odd
```

## ❌ [15. 3Sum](https://leetcode.com/problems/3sum/)

### 내용

정수 값을 리스트로 입력받아 세 개의 요소로 구성된 2차원 리스트(`ex) [[i, j, k], [x, y, z]]`로 반환해야 한다. 이때, 하나의 리스트(`[i, j, k]`)의 값은 서로 중첩되면 안 되며, 요소의 합이 0이 되어야 한다.

### 풀이

약 2시간 동안 두 번의 시도 끝에 결국에는 교재의 풀이 과정을 들여다보았다.

1. 세 개의 요소를 가진 리스트를 만들기 위해 3중 반복문으로 접근하였으나 시간 초과로 인해 실패하였다.
2. 교재에서 언급한 투 포인터 방식과 유사하게 구현은 하였으나, 중복 제거 처리 및 이미 확인한 값을 건너뛰는 코드를 구현하지 않아 실패하였다.

실패 원인 중 첫 번째 방식을 브루트 포스라고 한다. 이 방식으로 문제를 해결하려는 경우 시간 복잡도는 O(N<sup>3</sup>)이므로, 시간을 초과하게 된다.

(이따가 투 포인터 개념 정리...)

## ✔ [561. Array Partition I](https://leetcode.com/problems/array-partition-i/)

### 내용

길이가 2n인 정수 리스트를 입력받고, 정수를 n쌍으로 묶은 후 각각의 쌍의 최소값을 합한 결과가 최대가 되도록 반환하여야 한다.

#### 풀이

문제를 이해하는데까지 약 30분 정도 소요되었는데, 문제를 이해한 후에는 생각보다 간단하게 해결할 수 있었다. 문제에서는 길이가 2n인 정수 리스트를 입력으로 받고, 이를 n쌍으로 묶은 후 각각의 쌍을 최소값을 전부 더한 값이 최대가 되도록 반환할 것을 요구하고 있다. 즉, 길이가 6인 정수 리스트를 입력 받는 경우 n은 3이 되고, 리스트를 3조각으로 나누고 각각의 최소값을 모두 합한 값이 가장 큰 값으로 출력되어야 하는 것이다. 따라서, 오름차순으로 정렬하여 각각의 리스트에 왼쪽에 위치한 값이 최소값이 되게 하고 반복문을 통해 왼쪽값을 더해주는 방식으로 접근하였다.

1. 입력받는 리스트를 오름차순으로 정렬하고, 합계를 0으로 초기화한다.

```python
nums.sort()
sum = 0
```

2. 입력받은 리스트를 반복하면서 짝수`(0, 2, ..., 2n)` 번째 인덱스에 해당하는 값을 `1`의 합계에 더하고, 반복이 종료되면 합계를 반환한다.

```python
for i in range(0, len(nums), 2):
    sum += nums[i]

return sum
```